<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HmmOS: boot.md</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HmmOS
   </div>
   <div id="projectbrief">System for Operating</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">boot.md </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>These notes assume x86 booting onto a HDD using the MBR protocol. The protocol is implemented by the BIOS, and the machine will be in real mode (a.k.a. 16-bit mode or i8086 mode).</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Master Boot Record (MBR)</h1>
<p>The MBR is the first sector (boot sector) of a storage device and is identified by the "magic bytes" 0x55, 0xAA in byte offsets 0x01FE and 0x01FF respectively (end of a 512-byte "sector", even if the underlying storage device doesn't have 512-byte sectors). Additionally, the MBR contains the partition table (four 16-byte entries at 0x01BE through 0x01FD), so we only have 446 bytes for executable code at the start of the sector.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Offset   </th><th class="markdownTableHeadNone">Length   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0000   </td><td class="markdownTableBodyNone">446   </td><td class="markdownTableBodyNone">Executable code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x01BE   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">Partition 1 descriptor    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x01CE   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">Partition 2 descriptor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x01DE   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">Partition 3 descriptor    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x01EE   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">Partition 4 descriptor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x01FE   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">0x55, 0xAA   </td></tr>
</table>
<p>The BIOS will copy the boot sector to memory starting at 0x7C00, so the bootloader compilation/linking has to be aware of this.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Enabling A20 line</h1>
<p>The A20 line is needed to enable pin 20 of the memory bus. Otherwise this pin will always be set to 0, thus disabling all odd-megabytes of memory (i.e., 0x5ABCDE is treated as 0x4ABCDE). There are silly historical reasons for this (stemming from the silly backcompat with real mode segments) and even sillier non-standardized ways to enable/disable the A20 line. The <a href="https://wiki.osdev.org/A20_Line">OSDev wiki on the A20 line</a> is very thorough.</p>
<p>An annotated version of the <code>check_a20</code> function to check if the A20 line is enabled, in which case we don't have to enable it ourselves:</p>
<div class="fragment"><div class="line">es=0, ds=0xFFFF</div>
<div class="line">di=0x0500, si=0x0510</div>
<div class="line"> </div>
<div class="line">es:di = 0x0000:0x0500 = 0x000500</div>
<div class="line">ds:si = 0xFFFF:0x0510 = 0x100500</div>
<div class="line"> </div>
<div class="line">These values are 1MB apart. Importantly, neither of these should</div>
<div class="line">overlap bootloader code.</div>
<div class="line"> </div>
<div class="line">Save old values stored at these locations.</div>
<div class="line">Push them onto the stack.</div>
<div class="line"> </div>
<div class="line">Overwrite es:di with 0x00.</div>
<div class="line">Overwrite ds:si with 0xFF.</div>
<div class="line"> </div>
<div class="line">Check if es:di == 0xFF. If so, this means the A20 line isn&#39;t enabled.</div>
<div class="line"> </div>
<div class="line">(Then cleanup by restoring the old values at es:di and ds:si.)</div>
</div><!-- fragment --><p>It turns out that QEMU already enables the A20 line, which makes things simpler for us.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
x86 CPU modes</h1>
<p>Most of this is all silly and historical, but it's necessary for the booting process.</p>
<p>x86 starts in 16-bit <em>real mode</em>, for compatibility reasons back to the first x86 cpus (i8086). This does support 32-bit registers and addressing modes, but instructions are 16-bit, we only have direct mapping (i.e. we have segment:offset addresses, but no segmentation or paging). In general we're constrained to a 20-bit address space (except for unreal mode). In real mode the BIOS (in BIOS or UEFI compatibility mode) exposes some useful low-level tools via BIOS interrupts, e.g., simple display and disk read operations.</p>
<p>Then we need to enter <em>protected mode</em>, which is the primary CPU mode since i386 (32-bit x86). This allows for the use of segmentation and paging, as well as long mode (64-bit mode). We also lose access to the BIOS interrupts (in exchange for our own interrupt code set up in the IDT).</p>
<p>BIOS functions are useful for the early boot stages but it's fairly limiting. For example, we may want to copy the kernel from disk to memory, but the BIOS can address less than 1MB of memory. This means we have to copy 1MB chunks of the kernel in real mode, switch to protected mode to copy this to higher memory, and then switch back to real mode to repeat. There are two main ways around this: (1) enter <em>virtual 8086</em> (v8086) mode, which is an emulated real-mode within protected-mode; and (2) use <em>unreal mode</em>. Unreal mode is simply real mode with 32-bit GDT (data) descriptors. It turns out that GDT descriptors (like most CPU register descriptors) are cached, so setting a 32-bit protected-mode segment and then switching back to real mode allows for 32-bit addressing in real mode. This may be simpler than using v8086 mode since we're already familiar with writing plain real mode code.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Disk layout</h1>
<p>For this project, at least for now, there is a very simple disk layout assumed by the bootloader. There's no concept of filesystems, at least not for now.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Offset   </th><th class="markdownTableHeadNone">Length   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0000   </td><td class="markdownTableBodyNone">0x200   </td><td class="markdownTableBodyNone">MBR. Loaded into memory by the BIOS at 0x7C00.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x0200   </td><td class="markdownTableBodyNone">0x7C00   </td><td class="markdownTableBodyNone">Bootloader stage 1.5. Loaded into memory by the MBR at 0x7E00.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">??   </td><td class="markdownTableBodyNone">??   </td><td class="markdownTableBodyNone">Kernel binary file. Stored at the beginning of a partition.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md15"></a>
GDT layout</h1>
<p>We'll use a standard flat model for the GDT. We mostly need 32-bit descriptors, one for (code, data) x (ring 0, ring 3).</p>
<p>Additionally, we'll have one code segment for "big unreal mode" (with limit 0xFFFF) to avoid any edge cases with "huge unreal mode" due to the upper bits of eip not being set properly on mode switches.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">GDT descriptor   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Null descriptor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Ring 0 code (32-bit)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Ring 0 data (32-bit)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Ring 3 code (32-bit)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Ring 3 data (32-bit)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">Ring 0 code (16-bit)   </td></tr>
</table>
<p>We don't need 16-bit descriptors for switching back to real mode. Indeed, the whole point of unreal mode is to switch back to real mode using cached 32-bit GDT descriptors.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Bootloading strategy</h1>
<p>In lieu of reading filesystems to get the kernel ELF file (a la GRUB stage 1.5/2), a simpler method is to write the kernel to a fixed location on the disk (known at installation time) and have the bootloader load this fixed location image. LILO does something similar.</p>
<p>For now, this very simple method means: write the kernel to a "partition" and write the partition details to the MBR. Probably with some magic bytes so it's easy to identify.</p>
<p>A very simple script is provided to do this. It takes as input the compiled bootloader binary and the kernel binary: </p><div class="fragment"><div class="line">$ python3 scripts/install_bootloader.py \</div>
<div class="line">    -b out/boot.bin \</div>
<div class="line">    -k out/kernel.bin \</div>
<div class="line">    -o out/disk.bin</div>
</div><!-- fragment --><p>The resulting partition details can be read by <code>fdisk</code>. If the kernel file fits in a single sector, this would look like the following: </p><div class="fragment"><div class="line">$ /sbin/fdisk -l out/disk.bin</div>
<div class="line">Disk out/disk.bin: 1 MiB, 1049088 bytes, 2049 sectors</div>
<div class="line">Units: sectors of 1 * 512 = 512 bytes</div>
<div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div>
<div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div>
<div class="line">Disklabel type: dos</div>
<div class="line">Disk identifier: 0x00000000</div>
<div class="line"> </div>
<div class="line">Device        Boot Start   End Sectors  Size Id Type</div>
<div class="line">out/disk.bin1 *     2048  2048       1  512B ff BBT</div>
</div><!-- fragment --><p>The kernel is expected to be a flat binary file that will be loaded at the configurable <code>KERNEL_LOAD_ADDR</code>. Later we can parse and load an ELF file, but this is simpler to get started.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Bootloader TODO</h1>
<p>Rough order, may need additional steps. Roughly based on the list from <a href="https://wiki.osdev.org/Rolling_Your_Own_Bootloader">Rolling your own bootloader</a>.</p>
<p>Now all complete!</p>
<ul>
<li>[X] Set up MBR</li>
<li>[X] Set up basic printing<ul>
<li>[X] BIOS 0x10 function</li>
<li>[X] Basic printing functions</li>
</ul>
</li>
<li>[X] Copy rest of bootloader (stage 1.5) to memory</li>
<li>[X] Enable A20 line</li>
<li>[X] Enter protected mode<ul>
<li>[X] Load GDTR</li>
<li>[X] Enter unreal mode</li>
<li>[X] Enter protected mode again (for real this time)</li>
</ul>
</li>
<li>[X] Set up paging<ul>
<li>[X] HHDM (0xC0000000 through <code>KERNEL_LOAD_ADDR</code>: ~1GB low memory linear map)</li>
<li>[X] Direct map (only needed for the bootstrap process): first 1MB of memory</li>
<li>[X] Kernel map (starting at <code>KERNEL_LOAD_ADDR</code>)</li>
</ul>
</li>
<li>[ ] Prepare kernel<ul>
<li>[X] Load kernel to memory at fixed load address</li>
<li>[X] Jump to kernel (build a simple toy kernel)</li>
<li>[X] Report memory map and other capabilities to kernel </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>

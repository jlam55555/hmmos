<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HmmOS: util::IntrusiveListHead&lt; Parent, Tag &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HmmOS
   </div>
   <div id="projectbrief">System for Operating</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>util</b></li><li class="navelem"><a class="el" href="classutil_1_1IntrusiveListHead.html">IntrusiveListHead</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classutil_1_1IntrusiveListHead-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">util::IntrusiveListHead&lt; Parent, Tag &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A C++ version of the common linked list data structure (see <code>man 3 list</code>).  
 <a href="classutil_1_1IntrusiveListHead.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="intrusive__list_8h_source.html">intrusive_list.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1IntrusiveListHead_1_1Iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f788f20f0ae174f952c2cdb54e51bf2"><td class="memItemLeft" align="right" valign="top"><a id="a2f788f20f0ae174f952c2cdb54e51bf2" name="a2f788f20f0ae174f952c2cdb54e51bf2"></a>
<a class="el" href="structutil_1_1IntrusiveListHead_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a2f788f20f0ae174f952c2cdb54e51bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0750828abb7f41bd46703243ca9d0e48"><td class="memItemLeft" align="right" valign="top"><a id="a0750828abb7f41bd46703243ca9d0e48" name="a0750828abb7f41bd46703243ca9d0e48"></a>
<a class="el" href="structutil_1_1IntrusiveListHead_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a0750828abb7f41bd46703243ca9d0e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e3ceefda805851ba14ac68f09fd156"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1IntrusiveListHead.html#ad2e3ceefda805851ba14ac68f09fd156">IntrusiveListHead</a> ()=default</td></tr>
<tr class="memdesc:ad2e3ceefda805851ba14ac68f09fd156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty list.  <br /></td></tr>
<tr class="separator:ad2e3ceefda805851ba14ac68f09fd156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e41b8dce1fbb8bb3b5b2d8419947c2"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator It&gt; </td></tr>
<tr class="memitem:a86e41b8dce1fbb8bb3b5b2d8419947c2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classutil_1_1IntrusiveListHead.html#a86e41b8dce1fbb8bb3b5b2d8419947c2">IntrusiveListHead</a> (const It &amp;begin, const It &amp;end)</td></tr>
<tr class="memdesc:a86e41b8dce1fbb8bb3b5b2d8419947c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an IntrusiveListNode from an iterator range of <code>Parent</code> objects.  <br /></td></tr>
<tr class="separator:a86e41b8dce1fbb8bb3b5b2d8419947c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645f614962fe510cf19f9f4bdf34b9a9"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator It&gt; </td></tr>
<tr class="memitem:a645f614962fe510cf19f9f4bdf34b9a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classutil_1_1IntrusiveListHead.html#a645f614962fe510cf19f9f4bdf34b9a9">insert_back</a> (const It &amp;begin, const It &amp;end)</td></tr>
<tr class="memdesc:a645f614962fe510cf19f9f4bdf34b9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append elements from a different range of <code>Parent</code> objects.  <br /></td></tr>
<tr class="separator:a645f614962fe510cf19f9f4bdf34b9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059a1eb76e823122627f2b7d6ce19033"><td class="memItemLeft" align="right" valign="top"><a id="a059a1eb76e823122627f2b7d6ce19033" name="a059a1eb76e823122627f2b7d6ce19033"></a>
Parent &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>next</b> ()</td></tr>
<tr class="separator:a059a1eb76e823122627f2b7d6ce19033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f353a43c0523406c47b1047ac0cc19"><td class="memItemLeft" align="right" valign="top"><a id="a61f353a43c0523406c47b1047ac0cc19" name="a61f353a43c0523406c47b1047ac0cc19"></a>
const Parent &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>next</b> () const</td></tr>
<tr class="separator:a61f353a43c0523406c47b1047ac0cc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b04287bd18e9af0f422edc80363f49"><td class="memItemLeft" align="right" valign="top"><a id="a16b04287bd18e9af0f422edc80363f49" name="a16b04287bd18e9af0f422edc80363f49"></a>
Parent &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>prev</b> ()</td></tr>
<tr class="separator:a16b04287bd18e9af0f422edc80363f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e9c8f32d514fdaa39edfc38e715b88"><td class="memItemLeft" align="right" valign="top"><a id="aa4e9c8f32d514fdaa39edfc38e715b88" name="aa4e9c8f32d514fdaa39edfc38e715b88"></a>
const Parent &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>prev</b> () const</td></tr>
<tr class="separator:aa4e9c8f32d514fdaa39edfc38e715b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5d9bb31b1079a1e3ccf27e3eac4547"><td class="memItemLeft" align="right" valign="top">Parent &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1IntrusiveListHead.html#abd5d9bb31b1079a1e3ccf27e3eac4547">at</a> (int n)</td></tr>
<tr class="memdesc:abd5d9bb31b1079a1e3ccf27e3eac4547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element at n-th index.  <br /></td></tr>
<tr class="separator:abd5d9bb31b1079a1e3ccf27e3eac4547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1880acfa8a1f984aac5bbc60e5f3bf48"><td class="memItemLeft" align="right" valign="top"><a id="a1880acfa8a1f984aac5bbc60e5f3bf48" name="a1880acfa8a1f984aac5bbc60e5f3bf48"></a>
const Parent &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (int n) const</td></tr>
<tr class="separator:a1880acfa8a1f984aac5bbc60e5f3bf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07c0c3d4643cde2edf583d8b4897d6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1IntrusiveListHead.html#ae07c0c3d4643cde2edf583d8b4897d6b">empty</a> () const</td></tr>
<tr class="memdesc:ae07c0c3d4643cde2edf583d8b4897d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if circular list has no elements other than the sentinel.  <br /></td></tr>
<tr class="separator:ae07c0c3d4643cde2edf583d8b4897d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9526ed0e326a9a9242caf35408a32c77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structutil_1_1IntrusiveListHead_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1IntrusiveListHead.html#a9526ed0e326a9a9242caf35408a32c77">erase</a> ()</td></tr>
<tr class="memdesc:a9526ed0e326a9a9242caf35408a32c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the current node from the linked list.  <br /></td></tr>
<tr class="separator:a9526ed0e326a9a9242caf35408a32c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496596d93802f33809e560f9bd1a7099"><td class="memItemLeft" align="right" valign="top"><a id="a496596d93802f33809e560f9bd1a7099" name="a496596d93802f33809e560f9bd1a7099"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (Parent &amp;p)</td></tr>
<tr class="memdesc:a496596d93802f33809e560f9bd1a7099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node after the current node. <br /></td></tr>
<tr class="separator:a496596d93802f33809e560f9bd1a7099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d74e49752f91df053b38f5d67d959"><td class="memItemLeft" align="right" valign="top"><a id="a464d74e49752f91df053b38f5d67d959" name="a464d74e49752f91df053b38f5d67d959"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (Parent &amp;p)</td></tr>
<tr class="memdesc:a464d74e49752f91df053b38f5d67d959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node before the current node. <br /></td></tr>
<tr class="separator:a464d74e49752f91df053b38f5d67d959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4294a44adc540a19bbaa5bb27f7ad4c9"><td class="memItemLeft" align="right" valign="top"><a id="a4294a44adc540a19bbaa5bb27f7ad4c9" name="a4294a44adc540a19bbaa5bb27f7ad4c9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a4294a44adc540a19bbaa5bb27f7ad4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of this list, not including the sentinel node. <br /></td></tr>
<tr class="separator:a4294a44adc540a19bbaa5bb27f7ad4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb40db6ff52d8e64babe6627a6cb34ae"><td class="memItemLeft" align="right" valign="top"><a id="afb40db6ff52d8e64babe6627a6cb34ae" name="afb40db6ff52d8e64babe6627a6cb34ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:afb40db6ff52d8e64babe6627a6cb34ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all elements from a list. <br /></td></tr>
<tr class="separator:afb40db6ff52d8e64babe6627a6cb34ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Parent, typename Tag = void&gt;<br />
class util::IntrusiveListHead&lt; Parent, Tag &gt;</div><p>A C++ version of the common linked list data structure (see <code>man 3 list</code>). </p>
<p>In its well-known form, macros and <code>offsetof()</code> are used to for initialization and iteration.</p>
<p>Like the macro version, this is an intrusive, circular, doubly-linked list. Unlike the macro version, this only supports homogeneous nodes &ndash; you can't interpret the <code><a class="el" href="classutil_1_1IntrusiveListHead.html" title="A C++ version of the common linked list data structure (see man 3 list).">IntrusiveListHead</a></code> as being a member of different parent nodes. However, we shouldn't really be doing that anyways.</p>
<p><code><a class="el" href="classutil_1_1IntrusiveListHead.html" title="A C++ version of the common linked list data structure (see man 3 list).">IntrusiveListHead</a></code>s <b>assume they are data members of the parent node</b>. Constructing an <code><a class="el" href="classutil_1_1IntrusiveListHead.html" title="A C++ version of the common linked list data structure (see man 3 list).">IntrusiveListHead</a></code> explicitly (i.e., not as a base class of <code>Parent</code>) is allowed but only should be used to construct sentinel nodes, and care should be taken to not downcast these to objects of type <code>Parent</code>.</p>
<p><code><a class="el" href="classutil_1_1IntrusiveListHead.html" title="A C++ version of the common linked list data structure (see man 3 list).">IntrusiveListHead</a></code>s (just like the list macros, or ordinary non-intrusive lists) allow multiple participation. That is, the parent node can inherit from (contain) multiple <code><a class="el" href="classutil_1_1IntrusiveListHead.html" title="A C++ version of the common linked list data structure (see man 3 list).">IntrusiveListHead</a></code>s, which must be disambiguated using different tags. For example: </p><pre class="fragment">using MLPN = struct MultiParticipantListNode;
using MLPNList1 = IntrusiveListHead&lt;MLPN, struct Tag1&gt;;
using MLPNList2 = IntrusiveListHead&lt;MLPN, struct Tag2&gt;;
struct MultiParticipantListNode
    : public MLPNList1, public MLPNList2 {};

// Sentinel nodes; these are only the `IntrusiveListHead`
// subobject.
MLPNList1 list1;
MLPNList2 list2;

// Regular parent node. These can be inserted into a
// MLPNList1 and a MLPNList2 linked list.
MLPN node1, node2;

list1.push_front(node1);
node1.MLPNList1::push_front(node2);
list2.push_front(node2);

// (list1) -&gt; node1 -&gt; node2 -&gt; (list1)
// (list2) -&gt; node2 -&gt; (list2)
assert(list1.size() == 2);
assert(list2.size() == 1);

assert(node1.MLPNList1::size() == 2);
assert(node1.MLPNList2::size() == 0);
assert(node2.MLPNList1::size() == 2);
assert(node2.MLPNList2::size() == 1);
</pre><p>For comparison, see folly/boost's IntrusiveListHook/IntrusiveList implementation. This uses pointer-to-data-members and requires an explicit declaration of the list type rather than this approach, which uses inheritance. The benefit of that approach is it's not much more verbose, and allows the "list hook" (similar to a <code>struct list_head</code>) to be in an arbitrary location in the object rather than in the header. It's possible we'll need this down the road if we care about struct layouts, but this should be sufficient for the basic lists we need. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2e3ceefda805851ba14ac68f09fd156" name="ad2e3ceefda805851ba14ac68f09fd156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e3ceefda805851ba14ac68f09fd156">&#9670;&#160;</a></span>IntrusiveListHead() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Parent , typename Tag  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1IntrusiveListHead.html">util::IntrusiveListHead</a>&lt; Parent, Tag &gt;::IntrusiveListHead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty list. </p>
<p>This is either for a sentinel node that doesn't contain any elements, or for a non-sentinel node that has not been added to any lists. </p>

</div>
</div>
<a id="a86e41b8dce1fbb8bb3b5b2d8419947c2" name="a86e41b8dce1fbb8bb3b5b2d8419947c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e41b8dce1fbb8bb3b5b2d8419947c2">&#9670;&#160;</a></span>IntrusiveListHead() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Parent , typename Tag  = void&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1IntrusiveListHead.html">util::IntrusiveListHead</a>&lt; Parent, Tag &gt;::IntrusiveListHead </td>
          <td>(</td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an IntrusiveListNode from an iterator range of <code>Parent</code> objects. </p>
<p>See comment about stable addresses for <code><a class="el" href="classutil_1_1IntrusiveListHead.html#a645f614962fe510cf19f9f4bdf34b9a9" title="Append elements from a different range of Parent objects.">insert_back()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the sentinel node </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abd5d9bb31b1079a1e3ccf27e3eac4547" name="abd5d9bb31b1079a1e3ccf27e3eac4547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5d9bb31b1079a1e3ccf27e3eac4547">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Parent , typename Tag  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parent &amp; <a class="el" href="classutil_1_1IntrusiveListHead.html">util::IntrusiveListHead</a>&lt; Parent, Tag &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get element at n-th index. </p>
<p>Due to the nature of the sentinel node, indices are 1-indexed. Negative indices start from the back of the array. 0 indicates the current node, although that's probably not if you're calling this from the sentinel node.</p>
<p>Note that there is no check for the sentinel node, which is treated as any other node in the linked list. </p>

</div>
</div>
<a id="ae07c0c3d4643cde2edf583d8b4897d6b" name="ae07c0c3d4643cde2edf583d8b4897d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07c0c3d4643cde2edf583d8b4897d6b">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Parent , typename Tag  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classutil_1_1IntrusiveListHead.html">util::IntrusiveListHead</a>&lt; Parent, Tag &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if circular list has no elements other than the sentinel. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <code><a class="el" href="classutil_1_1IntrusiveListHead.html#a4294a44adc540a19bbaa5bb27f7ad4c9" title="Length of this list, not including the sentinel node.">size()</a> == 0</code>. </dd></dl>

</div>
</div>
<a id="a9526ed0e326a9a9242caf35408a32c77" name="a9526ed0e326a9a9242caf35408a32c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9526ed0e326a9a9242caf35408a32c77">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Parent , typename Tag  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structutil_1_1IntrusiveListHead_1_1Iterator.html">Iterator</a> <a class="el" href="classutil_1_1IntrusiveListHead.html">util::IntrusiveListHead</a>&lt; Parent, Tag &gt;::erase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the current node from the linked list. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator for the following element </dd></dl>

</div>
</div>
<a id="a645f614962fe510cf19f9f4bdf34b9a9" name="a645f614962fe510cf19f9f4bdf34b9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645f614962fe510cf19f9f4bdf34b9a9">&#9670;&#160;</a></span>insert_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Parent , typename Tag  = void&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classutil_1_1IntrusiveListHead.html">util::IntrusiveListHead</a>&lt; Parent, Tag &gt;::insert_back </td>
          <td>(</td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append elements from a different range of <code>Parent</code> objects. </p>
<p>Addresses of iterator elements are assumed to be stable and outlive the lifetime of any elements in the intrusive list. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/kernel/util/<a class="el" href="intrusive__list_8h_source.html">intrusive_list.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>

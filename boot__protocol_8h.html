<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HmmOS: src/common/boot_protocol.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HmmOS
   </div>
   <div id="projectbrief">System for Operating</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_fdedb0aba14d44ce9d99bc100e026e6a.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">boot_protocol.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The runtime interface between the bootloader and kernel.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="memdefs_8h_source.html">memdefs.h</a>&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for boot_protocol.h:</div>
<div class="dyncontent">
<div class="center"><img src="boot__protocol_8h__incl.png" border="0" usemap="#asrc_2common_2boot__protocol_8h" alt=""/></div>
<map name="asrc_2common_2boot__protocol_8h" id="asrc_2common_2boot__protocol_8h">
<area shape="rect" title="The runtime interface between the bootloader and kernel." alt="" coords="63,5,270,31"/>
<area shape="rect" href="memdefs_8h.html" title="Useful definitions related to memory sizing." alt="" coords="5,79,101,104"/>
<area shape="rect" title=" " alt="" coords="125,79,208,104"/>
<area shape="rect" title=" " alt="" coords="233,79,303,104"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="boot__protocol_8h__dep__incl.png" border="0" usemap="#asrc_2common_2boot__protocol_8hdep" alt=""/></div>
<map name="asrc_2common_2boot__protocol_8hdep" id="asrc_2common_2boot__protocol_8hdep">
<area shape="rect" title="The runtime interface between the bootloader and kernel." alt="" coords="165,5,371,31"/>
<area shape="rect" href="boot_2page__table_8h.html" title="Some useful definitions used by page_table.c." alt="" coords="5,86,168,111"/>
<area shape="rect" href="page__frame__table_8h.html" title="Page frame descriptors and page frame table." alt="" coords="193,79,343,119"/>
<area shape="rect" href="virt_8h.html" title="Virtual memory mapping." alt="" coords="367,86,521,111"/>
<area shape="rect" href="mbr_8h.html" title="Master Boot Record definitions." alt="" coords="29,174,144,199"/>
<area shape="rect" href="fat_8h.html" title="FAT32 driver for the bootloader. Only used to locate and load the kernel binary." alt="" coords="33,255,141,280"/>
<area shape="rect" href="page__frame__allocator_8h.html" title="Allocator for (4KB) physical page frames." alt="" coords="193,167,343,207"/>
</map>
</div>
</div>
<p><a href="boot__protocol_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structe820__mm__entry.html">e820_mm_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbp__req__header.html">bp_req_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbp__req__memory__map.html">bp_req_memory_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory map bootloader request.  <a href="structbp__req__memory__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8cf50ce50e5c69c8f5893969eec156ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot__protocol_8h.html#a8cf50ce50e5c69c8f5893969eec156ef">KERNEL_LOAD_ADDR</a>&#160;&#160;&#160;(4 * GB - 32 * MB)</td></tr>
<tr class="memdesc:a8cf50ce50e5c69c8f5893969eec156ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual address to load kernel text.  <br /></td></tr>
<tr class="separator:a8cf50ce50e5c69c8f5893969eec156ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c61c065ab14afc9896d9cca9369606f"><td class="memItemLeft" align="right" valign="top"><a id="a3c61c065ab14afc9896d9cca9369606f" name="a3c61c065ab14afc9896d9cca9369606f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KERNEL_MAP_SZ</b>&#160;&#160;&#160;(4 * GB - <a class="el" href="boot__protocol_8h.html#a8cf50ce50e5c69c8f5893969eec156ef">KERNEL_LOAD_ADDR</a>)</td></tr>
<tr class="separator:a3c61c065ab14afc9896d9cca9369606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0565e413bb83e0539ebc2006482544d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot__protocol_8h.html#aa0565e413bb83e0539ebc2006482544d">IO_MAP_SZ</a>&#160;&#160;&#160;(4 * MB)</td></tr>
<tr class="separator:aa0565e413bb83e0539ebc2006482544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78dc1d4a1d0d5cf33838872fd90afcc"><td class="memItemLeft" align="right" valign="top"><a id="ad78dc1d4a1d0d5cf33838872fd90afcc" name="ad78dc1d4a1d0d5cf33838872fd90afcc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BP_REQ_MAGIC</b>&#160;&#160;&#160;0xF7438B7CA1676C21ULL</td></tr>
<tr class="memdesc:ad78dc1d4a1d0d5cf33838872fd90afcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly generated. Used to identify bootloader requests in the kernel binary. <br /></td></tr>
<tr class="separator:ad78dc1d4a1d0d5cf33838872fd90afcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d1008de4db1234aaf549049a04e4b0"><td class="memItemLeft" align="right" valign="top"><a id="a79d1008de4db1234aaf549049a04e4b0" name="a79d1008de4db1234aaf549049a04e4b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BP_REQ_ALIGN</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a79d1008de4db1234aaf549049a04e4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bootloader will scan for any requests. This must be aligned to make the search faster for the bootloader. <br /></td></tr>
<tr class="separator:a79d1008de4db1234aaf549049a04e4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f8df310419bb3873356ab6d536f265"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot__protocol_8h.html#a00f8df310419bb3873356ab6d536f265">_BP_REQ_MEMORY_MAP</a>&#160;&#160;&#160;<a class="el" href="structbp__req__memory__map.html">bp_req_memory_map</a></td></tr>
<tr class="separator:a00f8df310419bb3873356ab6d536f265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47712fbaf979e1392e74f80c15575acd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot__protocol_8h.html#a47712fbaf979e1392e74f80c15575acd">BP_REQ</a>(REQ_ID,  VAR)</td></tr>
<tr class="memdesc:a47712fbaf979e1392e74f80c15575acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel interface for defining a bootloader request.  <br /></td></tr>
<tr class="separator:a47712fbaf979e1392e74f80c15575acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a539c68a0b5166670c9ac882503f12142"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot__protocol_8h.html#a539c68a0b5166670c9ac882503f12142">e820_mm_type</a> { <br />
&#160;&#160;<b>E820_MM_TYPE_USABLE</b> = 1
, <b>E820_MM_TYPE_RESERVED</b>
, <b>E820_MM_TYPE_ACPI_RECLAIMABLE</b>
, <b>E820_MM_TYPE_ACPI_NVS</b>
, <br />
&#160;&#160;<b>E820_MM_TYPE_BAD_MEM</b>
, <a class="el" href="boot__protocol_8h.html#a539c68a0b5166670c9ac882503f12142a01fb267f873a85d62fe62edde015cc75">E820_MM_TYPE_BOOTLOADER</a> = 6
, <a class="el" href="boot__protocol_8h.html#a539c68a0b5166670c9ac882503f12142aa5dfd9e969ea2ad1121652df9189ed3f">E820_MM_TYPE_BOOTLOADER_RECLAIMABLE</a> = 7
<br />
 }</td></tr>
<tr class="separator:a539c68a0b5166670c9ac882503f12142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35754974ef66773440111c2bdd24ea27"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot__protocol_8h.html#a35754974ef66773440111c2bdd24ea27">bp_req_id</a> { <a class="el" href="boot__protocol_8h.html#a35754974ef66773440111c2bdd24ea27aa91fc843033745075c1e450debe7fba8">BP_REQID_MEMORY_MAP</a> = 1
 }</td></tr>
<tr class="separator:a35754974ef66773440111c2bdd24ea27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1b0af7a607578ef2947c7be7520c07e7"><td class="memItemLeft" align="right" valign="top"><a id="a1b0af7a607578ef2947c7be7520c07e7" name="a1b0af7a607578ef2947c7be7520c07e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_Static_assert</b> (HUGEPG_ALIGNED(<a class="el" href="boot__protocol_8h.html#a8cf50ce50e5c69c8f5893969eec156ef">KERNEL_LOAD_ADDR</a>), &quot;KERNEL_LOAD_ADDR must be hugepage-aligned&quot;)</td></tr>
<tr class="separator:a1b0af7a607578ef2947c7be7520c07e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884db0b8844450930b373b24fb49ebc1"><td class="memItemLeft" align="right" valign="top"><a id="a884db0b8844450930b373b24fb49ebc1" name="a884db0b8844450930b373b24fb49ebc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_Static_assert</b> (HUGEPG_ALIGNED(<a class="el" href="boot__protocol_8h.html#aa0565e413bb83e0539ebc2006482544d">IO_MAP_SZ</a>), &quot;IO_MAP_SZ must be hugepage-aligned&quot;)</td></tr>
<tr class="separator:a884db0b8844450930b373b24fb49ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e23733577778e55b54da9955733b2f"><td class="memItemLeft" align="right" valign="top"><a id="a91e23733577778e55b54da9955733b2f" name="a91e23733577778e55b54da9955733b2f"></a>
struct <a class="el" href="structbp__req__header.html">bp_req_header</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((packed))</td></tr>
<tr class="separator:a91e23733577778e55b54da9955733b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b82291742c88062f2f022a8a1ddbc51"><td class="memItemLeft" align="right" valign="top"><a id="a4b82291742c88062f2f022a8a1ddbc51" name="a4b82291742c88062f2f022a8a1ddbc51"></a>
struct <a class="el" href="structbp__req__memory__map.html">bp_req_memory_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((packed, aligned(<a class="el" href="boot__protocol_8h.html#a79d1008de4db1234aaf549049a04e4b0">BP_REQ_ALIGN</a>)))</td></tr>
<tr class="separator:a4b82291742c88062f2f022a8a1ddbc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abbd697aa46868a5c5ab51e2a9a784851"><td class="memItemLeft" align="right" valign="top"><a id="abbd697aa46868a5c5ab51e2a9a784851" name="abbd697aa46868a5c5ab51e2a9a784851"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>magic</b></td></tr>
<tr class="separator:abbd697aa46868a5c5ab51e2a9a784851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d37c447ae471d22da0cc627286f04a"><td class="memItemLeft" align="right" valign="top"><a id="a69d37c447ae471d22da0cc627286f04a" name="a69d37c447ae471d22da0cc627286f04a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>req_id</b></td></tr>
<tr class="separator:a69d37c447ae471d22da0cc627286f04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321e08a6cc9f3b94435d45688955687a"><td class="memItemLeft" align="right" valign="top"><a id="a321e08a6cc9f3b94435d45688955687a" name="a321e08a6cc9f3b94435d45688955687a"></a>
struct <a class="el" href="structbp__req__header.html">bp_req_header</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hdr</b></td></tr>
<tr class="separator:a321e08a6cc9f3b94435d45688955687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80e2f3f2aa9d990784bec463a986b46"><td class="memItemLeft" align="right" valign="top"><a id="ab80e2f3f2aa9d990784bec463a986b46" name="ab80e2f3f2aa9d990784bec463a986b46"></a>
struct <a class="el" href="structe820__mm__entry.html">e820_mm_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>memory_map</b></td></tr>
<tr class="separator:ab80e2f3f2aa9d990784bec463a986b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The runtime interface between the bootloader and kernel. </p>
<p>The bootloader can share data with the kernel (e.g., physical memory map) and the kernel can request bootloader functionality (e.g., video mode) via this interface. Design heavily inspired by the Limine boot protocol.</p>
<p>See the <a class="el" href="boot__protocol_8h.html#a47712fbaf979e1392e74f80c15575acd" title="Kernel interface for defining a bootloader request.">BP_REQ()</a> macro for the kernel-level interface for declaring kernel requests. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a00f8df310419bb3873356ab6d536f265" name="a00f8df310419bb3873356ab6d536f265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f8df310419bb3873356ab6d536f265">&#9670;&#160;</a></span>_BP_REQ_MEMORY_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _BP_REQ_MEMORY_MAP&#160;&#160;&#160;<a class="el" href="structbp__req__memory__map.html">bp_req_memory_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helpers for BP_REQ, since (afaik) the preprocessor doesn't have functionality to change the case of tokens. </p>

</div>
</div>
<a id="a47712fbaf979e1392e74f80c15575acd" name="a47712fbaf979e1392e74f80c15575acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47712fbaf979e1392e74f80c15575acd">&#9670;&#160;</a></span>BP_REQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BP_REQ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">REQ_ID, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">VAR&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">struct </span>_BP_REQ_##REQ_ID VAR = {                                              \</div>
<div class="line">      .hdr = {.magic = <a class="code hl_define" href="boot__protocol_8h.html#ad78dc1d4a1d0d5cf33838872fd90afcc">BP_REQ_MAGIC</a>, .req_id = BP_REQID_##REQ_ID}};</div>
<div class="ttc" id="aboot__protocol_8h_html_ad78dc1d4a1d0d5cf33838872fd90afcc"><div class="ttname"><a href="boot__protocol_8h.html#ad78dc1d4a1d0d5cf33838872fd90afcc">BP_REQ_MAGIC</a></div><div class="ttdeci">#define BP_REQ_MAGIC</div><div class="ttdoc">Randomly generated. Used to identify bootloader requests in the kernel binary.</div><div class="ttdef"><b>Definition:</b> boot_protocol.h:91</div></div>
</div><!-- fragment -->
<p>Kernel interface for defining a bootloader request. </p>
<p>The request object needs to be a global variable and not optimized out of the binary.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">const</span> <a class="code hl_define" href="boot__protocol_8h.html#a47712fbaf979e1392e74f80c15575acd">BP_REQ</a>(MEMORY_MAP, _mem_map_req);</div>
<div class="ttc" id="aboot__protocol_8h_html_a47712fbaf979e1392e74f80c15575acd"><div class="ttname"><a href="boot__protocol_8h.html#a47712fbaf979e1392e74f80c15575acd">BP_REQ</a></div><div class="ttdeci">#define BP_REQ(REQ_ID, VAR)</div><div class="ttdoc">Kernel interface for defining a bootloader request.</div><div class="ttdef"><b>Definition:</b> boot_protocol.h:148</div></div>
</div><!-- fragment --><p> This is akin to defining <code>struct <a class="el" href="structbp__req__memory__map.html" title="Memory map bootloader request.">bp_req_memory_map</a> _mem_map_req</code> with the required magic variables and request ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">REQ_ID</td><td>the name of the request. It should be all caps and not include the BP_REQID/bp_req prefix. </td></tr>
    <tr><td class="paramname">VAR</td><td>the name of the struct we're declaring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0565e413bb83e0539ebc2006482544d" name="aa0565e413bb83e0539ebc2006482544d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0565e413bb83e0539ebc2006482544d">&#9670;&#160;</a></span>IO_MAP_SZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IO_MAP_SZ&#160;&#160;&#160;(4 * MB)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Some reserved space in the high memory virtual address space for remapping I/O ports and device memory-mapped memory. See <a class="el" href="virt_8h.html" title="Virtual memory mapping.">kernel/mm/virt.h</a> for more info. </p>

</div>
</div>
<a id="a8cf50ce50e5c69c8f5893969eec156ef" name="a8cf50ce50e5c69c8f5893969eec156ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf50ce50e5c69c8f5893969eec156ef">&#9670;&#160;</a></span>KERNEL_LOAD_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KERNEL_LOAD_ADDR&#160;&#160;&#160;(4 * GB - 32 * MB)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual address to load kernel text. </p>
<p>Save 32MB at the top of the virtual address space for the kernel load address. This also dictates the maximum size of the kernel binary, so this will need to be overridden (and the linker script modified) if the kernel binary size exceeds this.</p>
<p>This is a compromise due to the limited size of the 32-bit address space, and the fact that we want the kernel to be loaded at a fixed address (i.e., nothing fancy like PIE). The larger this section is, the more space we take away from the 1GB HHDM, so the kernel will be able to address less memory without creating its own memory mappings.</p>
<p>TODO: This could be a kernel request, although I'm not sure how useful that would be. The kernel size is known at compile-time so this should mostly be fine. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a35754974ef66773440111c2bdd24ea27" name="a35754974ef66773440111c2bdd24ea27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35754974ef66773440111c2bdd24ea27">&#9670;&#160;</a></span>bp_req_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="boot__protocol_8h.html#a35754974ef66773440111c2bdd24ea27">bp_req_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a35754974ef66773440111c2bdd24ea27aa91fc843033745075c1e450debe7fba8" name="a35754974ef66773440111c2bdd24ea27aa91fc843033745075c1e450debe7fba8"></a>BP_REQID_MEMORY_MAP&#160;</td><td class="fielddoc"><p>As a sanity check, a zero reqid is treated as an error. Start at index 1. </p>
</td></tr>
</table>

</div>
</div>
<a id="a539c68a0b5166670c9ac882503f12142" name="a539c68a0b5166670c9ac882503f12142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539c68a0b5166670c9ac882503f12142">&#9670;&#160;</a></span>e820_mm_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="boot__protocol_8h.html#a539c68a0b5166670c9ac882503f12142">e820_mm_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a539c68a0b5166670c9ac882503f12142a01fb267f873a85d62fe62edde015cc75" name="a539c68a0b5166670c9ac882503f12142a01fb267f873a85d62fe62edde015cc75"></a>E820_MM_TYPE_BOOTLOADER&#160;</td><td class="fielddoc"><p>Bootloader-allocated memory. Includes bootloader stack, and page tables, and kernel text region, which are all used by the HmmOS kernel and thus cannot be reclaimed. (This is different than the Limine boot protocol which assumes the kernel will set up its own stack and text regions, and thus those regions are reclaimable.) </p>
</td></tr>
<tr><td class="fieldname"><a id="a539c68a0b5166670c9ac882503f12142aa5dfd9e969ea2ad1121652df9189ed3f" name="a539c68a0b5166670c9ac882503f12142aa5dfd9e969ea2ad1121652df9189ed3f"></a>E820_MM_TYPE_BOOTLOADER_RECLAIMABLE&#160;</td><td class="fielddoc"><p>Bootloader-allocated memory that can be reclaimed by the kernel. Includes dynamic memory allocated by the kernel and bootloader text regions. Can be treated as usable memory by the kernel. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>

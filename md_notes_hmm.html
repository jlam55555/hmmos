<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HmmOS: hmm.md</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HmmOS
   </div>
   <div id="projectbrief">System for Operating</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">hmm.md </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Interesting observations and debugging sessions</p>
<h1><a class="anchor" id="autotoc_md28"></a>
slow memory speed</h1>
<p>When I was first experimenting with my kernel thread implementation, I came across an <strike>frustrating</strike> interesting result: some threads were absurdly faster than others at doing the same deterministic tasks.</p>
<p>It turns out only the initial kernel thread was slow. It was slow due to operations on its stack. The stack was allocated in the bootloader, unlike the stack for other kernel threads which is allocated via a simple sequential arena. The kernel stack is allocated just under the MBR bootloader load address (physical address 0x7C00, HHDM virt address 0xC0007C00), while other threads' stacks are allocated on some higher page-aligned memory address.</p>
<p>Here's some test code to illustrate this:</p>
<div class="fragment"><div class="line">#define change_stk(stk) __asm__ volatile(&quot;mov %0, %%esp&quot; : : &quot;rm&quot;(stk))</div>
<div class="line"> </div>
<div class="line">void print_stk() {</div>
<div class="line">  void *stk;</div>
<div class="line">  __asm__ volatile(&quot;mov %%esp, %0&quot; : &quot;=m&quot;(stk));</div>
<div class="line">  nonstd::printf(&quot;stk=%x\r\n&quot;, (unsigned)stk);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void do_something() {</div>
<div class="line">  constexpr unsigned n = 1&#39;000&#39;000;</div>
<div class="line">  int j = 1;</div>
<div class="line">  uint64_t start = arch::time::rdtsc();</div>
<div class="line">  for (int i = 0; i &lt; n; ++i) {</div>
<div class="line">    j *= 2;</div>
<div class="line">  }</div>
<div class="line">  uint64_t end = arch::time::rdtsc();</div>
<div class="line">  nonstd::printf(&quot;cycles/op=%llu\r\n&quot;, (end - start) / n);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__attribute__((section(&quot;.text.entry&quot;))) void _entry() {</div>
<div class="line">  // Stack is originally just under the bootloader.</div>
<div class="line">  print_stk();</div>
<div class="line">  do_something();</div>
<div class="line"> </div>
<div class="line">  // Change stack to a random address on a different page.</div>
<div class="line">  change_stk((char *)0xC000B000);</div>
<div class="line">  print_stk();</div>
<div class="line">  do_something();</div>
<div class="line"> </div>
<div class="line">  // Change it back just to make sure it wasn&#39;t really slow the first</div>
<div class="line">  // time.</div>
<div class="line">  change_stk((char *)0xC0007bd0);</div>
<div class="line">  print_stk();</div>
<div class="line">  do_something();</div>
<div class="line"> </div>
<div class="line">  acpi::shutdown();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output (compiled with clang with -O1):</p>
<div class="fragment"><div class="line">stk=c0007bd0</div>
<div class="line">cycles/op=3060</div>
<div class="line">stk=c000afe0</div>
<div class="line">cycles/op=8</div>
<div class="line">stk=c0007bb0</div>
<div class="line">cycles/op=3068</div>
</div><!-- fragment --><p>Just to make sure this wasn't something wrong with my timing function (rdtsc), I tried the following example, which shouldn't involve any memory operations:</p>
<div class="fragment"><div class="line">void do_something() {</div>
<div class="line">  nonstd::printf(&quot;time between rdtsc=%llu\r\n&quot;,</div>
<div class="line">                 -(arch::time::rdtsc() - arch::time::rdtsc()));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output:</p>
<div class="fragment"><div class="line">stk=c0007bd0</div>
<div class="line">time between rdtsc=10963</div>
<div class="line">stk=c000afe0</div>
<div class="line">time between rdtsc=190</div>
<div class="line">stk=c0007bb0</div>
<div class="line">time between rdtsc=3306</div>
</div><!-- fragment --><p>Huh? Is my rdtsc screwed? Let's look at the disassembly:</p>
<div class="fragment"><div class="line">$ objdump -CDr out.O1/kernel/entry.o</div>
<div class="line">...</div>
<div class="line">00000030 &lt;do_something()&gt;:</div>
<div class="line">  30:   55                      push   %ebp</div>
<div class="line">  31:   89 e5                   mov    %esp,%ebp</div>
<div class="line">  33:   56                      push   %esi</div>
<div class="line">  34:   83 ec 14                sub    $0x14,%esp</div>
<div class="line">  37:   e8 fc ff ff ff          call   38 &lt;do_something()+0x8&gt;</div>
<div class="line">                        38: R_386_PC32  arch::time::rdtsc()</div>
<div class="line">  3c:   89 c6                   mov    %eax,%esi</div>
<div class="line">  3e:   89 55 f8                mov    %edx,-0x8(%ebp)</div>
<div class="line">  41:   e8 fc ff ff ff          call   42 &lt;do_something()+0x12&gt;</div>
<div class="line">                        42: R_386_PC32  arch::time::rdtsc()</div>
<div class="line">  46:   89 c1                   mov    %eax,%ecx</div>
<div class="line">  48:   8b 45 f8                mov    -0x8(%ebp),%eax</div>
<div class="line">  4b:   29 f1                   sub    %esi,%ecx</div>
<div class="line">  4d:   19 c2                   sbb    %eax,%edx</div>
<div class="line">  4f:   89 e0                   mov    %esp,%eax</div>
<div class="line">  51:   89 50 08                mov    %edx,0x8(%eax)</div>
<div class="line">  54:   89 48 04                mov    %ecx,0x4(%eax)</div>
<div class="line">  57:   c7 00 09 00 00 00       movl   $0x9,(%eax)</div>
<div class="line">                        59: R_386_32    .rodata.str1.1</div>
<div class="line">  5d:   e8 fc ff ff ff          call   5e &lt;do_something()+0x2e&gt;</div>
<div class="line">                        5e: R_386_PC32  printf</div>
<div class="line">  62:   83 c4 14                add    $0x14,%esp</div>
<div class="line">  65:   5e                      pop    %esi</div>
<div class="line">  66:   5d                      pop    %ebp</div>
<div class="line">  67:   c3                      ret</div>
</div><!-- fragment --><p>So it turns out we store a temporary between the two calls at instruction 3e (writing to <code>-0x8(ebp)</code>. Let's optimize this away by hand.</p>
<div class="fragment"><div class="line">void do_something() {</div>
<div class="line">  uint64_t res;</div>
<div class="line">  __asm__ volatile(&quot;rdtsc\n\t&quot;</div>
<div class="line">                   &quot;mov %%eax, %%esi\n\t&quot;</div>
<div class="line">                   &quot;mov %%edx, %%edi\n\t&quot;</div>
<div class="line">                   &quot;rdtsc\n\t&quot;</div>
<div class="line">                   &quot;sub %%esi, %%eax\n\t&quot;</div>
<div class="line">                   &quot;sbb %%edi, %%edx\n\t&quot;</div>
<div class="line">                   &quot;mov %%eax, %0\n\t&quot;</div>
<div class="line">                   &quot;mov %%edx, %1\n\t&quot;</div>
<div class="line">                   : &quot;=m&quot;(*(uint32_t *)&amp;res), &quot;=m&quot;(*(((uint32_t *)&amp;res) + 1))</div>
<div class="line">                   :</div>
<div class="line">                   : &quot;%eax&quot;, &quot;%edx&quot;, &quot;%esi&quot;, &quot;%edi&quot;);</div>
<div class="line">  nonstd::printf(&quot;time between rdtsc=%llu\r\n&quot;, res);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output:</p>
<div class="fragment"><div class="line">stk=c0007bd0</div>
<div class="line">time between rdtsc=76</div>
<div class="line">stk=c000afe0</div>
<div class="line">time between rdtsc=19</div>
<div class="line">stk=c0007bb0</div>
<div class="line">time between rdtsc=38</div>
</div><!-- fragment --><p>Ok, much better. So the memory (stack) operation is indeed the culprit. Let's continue to narrow down the problem. Which memory operations are slow? Let's iterate page-by-page over the first 1GB of memory (since this is mapped by the bootloader in the HHDM).</p>
<div class="fragment"><div class="line">void do_write(size_t addr) {</div>
<div class="line">  constexpr int n = 10&#39;000;</div>
<div class="line">  uint64_t start = arch::time::rdtsc();</div>
<div class="line">  for (int i = 0; i &lt; n; ++i) {</div>
<div class="line">    // Write to the memory address and then restore the value so we</div>
<div class="line">    // don&#39;t blow up the system.</div>
<div class="line">    //</div>
<div class="line">    // Note that we can&#39;t do `mov (%0), (%0)` since memory- memory</div>
<div class="line">    // operations are disallowed in x86.</div>
<div class="line">    //</div>
<div class="line">    // Note also that just reading the value doesn&#39;t seem to</div>
<div class="line">    // experience a slowdown, only writing the value. So `mov (%0),</div>
<div class="line">    // %eax` does not experience the slowdown.</div>
<div class="line">    __asm__ volatile(&quot;mov %0, %%eax\n\t&quot;</div>
<div class="line">                     &quot;mov %%eax, %0&quot;</div>
<div class="line">                     : &quot;=m&quot;(*(int *)addr)</div>
<div class="line">                     :</div>
<div class="line">                     : &quot;eax&quot;);</div>
<div class="line">  }</div>
<div class="line">  uint64_t end = arch::time::rdtsc();</div>
<div class="line">  if (auto cycles_per_op = (end - start) / n; cycles_per_op &gt;= 500) {</div>
<div class="line">    nonstd::printf(&quot;addr=%x cycles/op=%llu\r\n&quot;, addr, cycles_per_op);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__attribute__((section(&quot;.text.entry&quot;))) void _entry() {</div>
<div class="line">  // We&#39;ve established stack is slow, so let&#39;s go somewhere else just</div>
<div class="line">  // to speed things up a bit.</div>
<div class="line">  change_stk(0xDEADBEEF);</div>
<div class="line"> </div>
<div class="line">  constexpr size_t hhdm_start = 0xC0000000;</div>
<div class="line">  constexpr size_t hhdm_end = 0x00000000; // overflow</div>
<div class="line">  constexpr size_t pg_sz = 4096;</div>
<div class="line"> </div>
<div class="line">  for (size_t pg = hhdm_start; pg != hhdm_end; pg += pg_sz) {</div>
<div class="line">    do_write(pg);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  acpi::shutdown();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output:</p>
<div class="fragment"><div class="line">$ make run OPT=1</div>
<div class="line">addr=c0007000 cycles/op=1512</div>
<div class="line">addr=c0008000 cycles/op=4103</div>
<div class="line">addr=c0009000 cycles/op=633</div>
<div class="line">addr=c00bf000 cycles/op=2649</div>
<div class="line">addr=c00e9000 cycles/op=2005</div>
<div class="line">addr=c00ea000 cycles/op=936</div>
<div class="line">addr=c00eb000 cycles/op=2112</div>
<div class="line">addr=c00ec000 cycles/op=1276</div>
<div class="line">addr=c00ed000 cycles/op=731</div>
<div class="line">addr=c00ee000 cycles/op=1207</div>
<div class="line">addr=c00ef000 cycles/op=889</div>
<div class="line">addr=c0405000 cycles/op=989</div>
<div class="line">addr=c0407000 cycles/op=1180</div>
<div class="line">addr=c0408000 cycles/op=914</div>
<div class="line">addr=c0409000 cycles/op=511</div>
<div class="line">addr=fe005000 cycles/op=1003</div>
<div class="line">addr=fe007000 cycles/op=1188</div>
<div class="line">addr=fe008000 cycles/op=942</div>
<div class="line">addr=fe009000 cycles/op=511</div>
</div><!-- fragment --><p>I'm able to get this result pretty consistently when running this multiple times. Now here's where things get really interesting: the results change when compiling with different options (using gcc, or switching optimization levels). It's a little nuanced but the results are consistent.</p>
<div class="fragment"><div class="line">$ make run OPT=1 GNU=1</div>
<div class="line">addr=c0007000 cycles/op=1550</div>
<div class="line">addr=c0008000 cycles/op=4097</div>
<div class="line">addr=c00e9000 cycles/op=1899</div>
<div class="line">addr=c00ea000 cycles/op=913</div>
<div class="line">addr=c00eb000 cycles/op=2135</div>
<div class="line">addr=c00ec000 cycles/op=1295</div>
<div class="line">addr=c00ed000 cycles/op=730</div>
<div class="line">addr=c00ee000 cycles/op=1227</div>
<div class="line">addr=c00ef000 cycles/op=904</div>
<div class="line">addr=c0404000 cycles/op=1006</div>
<div class="line">addr=c0405000 cycles/op=1377</div>
<div class="line">addr=c0407000 cycles/op=566</div>
<div class="line">addr=fe004000 cycles/op=1011</div>
<div class="line">addr=fe005000 cycles/op=1383</div>
<div class="line">addr=fe007000 cycles/op=575</div>
</div><!-- fragment --><p>The 500 threshold is chosen to illustrate the following point. Most of the reads/writes are much quicker. Here are the cycles/loop for more typical memory pages.</p>
<div class="fragment"><div class="line">addr=c0d35000 cycles/op=12</div>
<div class="line">addr=c0d36000 cycles/op=12</div>
<div class="line">addr=c0d37000 cycles/op=12</div>
<div class="line">addr=c0d38000 cycles/op=12</div>
<div class="line">addr=c0d39000 cycles/op=12</div>
<div class="line">addr=c0d3a000 cycles/op=12</div>
<div class="line">addr=c0d3b000 cycles/op=12</div>
<div class="line">addr=c0d3c000 cycles/op=12</div>
<div class="line">addr=c0d3d000 cycles/op=12</div>
</div><!-- fragment --><p>There are some pretty telling details here! First of all, you can see that the memory page containing the original slow stack (0xC0007000) is on this list.</p>
<p>But before I talk about the interesting relevations, I first want to check two things.</p>
<p>Firstly, does this slowness affect reads and/or writes? We can modify the above snippet to only do the read (safe) or only do the write (unsafe since we're overwriting arbitrary memory, which could include the stack or text regions). It turns out that only the write is affected. Reads consistently take 5 cycles/op and never cause these outliers, whereas writes usually take 7 cycles/op but form the peaks shown above.</p>
<p>Secondly, does this slowness happen at the page level or something more granular? Let's look at pages 0xC0006000 (fast), 0xC0007000 (slow), 0xC0008000 (even slower). Let's update the main loop:</p>
<div class="fragment"><div class="line">for (size_t addr = 0xC0006000; addr &lt; 0xC0009000; addr += 512) {</div>
<div class="line">  do_write(addr);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output:</p>
<div class="fragment"><div class="line">addr=c0006000 cycles/op=16</div>
<div class="line">addr=c0006200 cycles/op=12</div>
<div class="line">addr=c0006400 cycles/op=12</div>
<div class="line">addr=c0006600 cycles/op=11</div>
<div class="line">addr=c0006800 cycles/op=12</div>
<div class="line">addr=c0006a00 cycles/op=12</div>
<div class="line">addr=c0006c00 cycles/op=12</div>
<div class="line">addr=c0006e00 cycles/op=12</div>
<div class="line">addr=c0007000 cycles/op=1553</div>
<div class="line">addr=c0007200 cycles/op=1541</div>
<div class="line">addr=c0007400 cycles/op=1565</div>
<div class="line">addr=c0007600 cycles/op=1543</div>
<div class="line">addr=c0007800 cycles/op=1554</div>
<div class="line">addr=c0007a00 cycles/op=1550</div>
<div class="line">addr=c0007c00 cycles/op=1533</div>
<div class="line">addr=c0007e00 cycles/op=1505</div>
<div class="line">addr=c0008000 cycles/op=4145</div>
<div class="line">addr=c0008200 cycles/op=4112</div>
<div class="line">addr=c0008400 cycles/op=4114</div>
<div class="line">addr=c0008600 cycles/op=4063</div>
<div class="line">addr=c0008800 cycles/op=4021</div>
<div class="line">addr=c0008a00 cycles/op=3971</div>
<div class="line">addr=c0008c00 cycles/op=3957</div>
<div class="line">addr=c0008e00 cycles/op=3937</div>
</div><!-- fragment --><p>It turns out this is very page-oriented behavior. This is enough to form a hypothesis. Here are some facts.</p>
<ol type="1">
<li>The slowness occurs only on writes and happens on a per-page basis. The only hardware-related page slowness is page faults, but this should only happen on the first page access and shouldn't be noticeable when averaged over many loop cycles.</li>
<li>The general behavior is consistent across compilers and optimization levels, which indicates that this is not a software inefficiency or bug.</li>
<li>All of the slow pages are special:<ul>
<li>0xC0007000 and following pages: These are bootloader pages. The initial 512-byte MBR sector is loaded at 0x7C00 (0xC0007C00 in the HHDM), and the following 63 sectors are copied in by the bootloader immediately afterwards in low memory. Incidentally, the kernel stack coinhabits the page 0xC0007000 &ndash; it starts at 0xC0006FFF and grows downwards.</li>
<li>0xC00B8000-0xC00EF000: These are standard hardware-mapped (I/O) memory. The OSDev wiki has a <a href="https://wiki.osdev.org/Memory_Map_(x86)#Overview">good summary</a>. It makes sense that these are slow, so we can ignore them for the sake of this discussion.</li>
<li>0xC0400000 and following pages: The bootloader copies the kernel to the first unused hugepage in low memory (0x400000 physical address, 0xC0400000 in the HHDM).</li>
<li>0xFE000000 and following pages: These are the kernel virtual mapping and also map to the physical address 0x400000.</li>
</ul>
</li>
<li>Which exact pages are slow in the kernel mapping region depends on the compiler options and choice of compiler.</li>
<li>The slowness only happens for writes, not reads.</li>
</ol>
<p>(1) and (2) point to this being a feature of the QEMU emulator. (3) and (4) indicate that the behavior relates to the BIOS and kernel text regions. So the hypothesis is that writing anywhere on a page containing executable instructions in QEMU is slow.</p>
<p>Well, how does QEMU know that code is executable? Well, I guess that the code is only slow if we've actually executed instructions on that memory page. This of course depends on the compiler and compiler options, which explains (4). We can check this by stepping through the debugger and seeing which instructions we run. Since we have such a simple example, it should be easy to step through the program. In the case of clang with -O1, we see that we indeed execute kernel code on the slow kernel pages:</p>
<div class="fragment"><div class="line">fe000000 _entry</div>
<div class="line">fe005000 do_write</div>
<div class="line">fe007000 printf code</div>
<div class="line">fe008000 more printf code</div>
<div class="line">fe009000 more printf code</div>
</div><!-- fragment --><p>(Yes, there's a lot of printf code there.) To test this hypothesis further, let's try to avoid calling the printf code until after we've done all the benchmarking. Then it shouldn't show up as a slow page, right? Seems that's the case:</p>
<div class="fragment"><div class="line">addr=c0007000 cycles/op=1547</div>
<div class="line">addr=c0008000 cycles/op=4112</div>
<div class="line">addr=c0009000 cycles/op=646</div>
<div class="line">addr=c00b8000 cycles/op=407</div>
<div class="line">addr=c00b9000 cycles/op=317</div>
<div class="line">addr=c00ba000 cycles/op=320</div>
<div class="line">addr=c00bb000 cycles/op=317</div>
<div class="line">addr=c00bc000 cycles/op=307</div>
<div class="line">addr=c00bd000 cycles/op=304</div>
<div class="line">addr=c00be000 cycles/op=306</div>
<div class="line">addr=c00bf000 cycles/op=307</div>
<div class="line">addr=c00e9000 cycles/op=1858</div>
<div class="line">addr=c00ea000 cycles/op=896</div>
<div class="line">addr=c00eb000 cycles/op=2104</div>
<div class="line">addr=c00ec000 cycles/op=1268</div>
<div class="line">addr=c00ed000 cycles/op=733</div>
<div class="line">addr=c00ee000 cycles/op=1205</div>
<div class="line">addr=c00ef000 cycles/op=882</div>
<div class="line">addr=c0400000 cycles/op=302</div>
<div class="line">addr=c0405000 cycles/op=398</div>
<div class="line">addr=fe000000 cycles/op=305</div>
<div class="line">addr=fe005000 cycles/op=401</div>
</div><!-- fragment --><p>Importantly, the pages with the <code>printf()</code> implementation aren't slow anymore! Interestingly, I had to turn the threshold down to 300 to see the effect, which was very reproducible. Which brings me to the next question: is the slowness a function of the number of executable lines executed? That might make sense given that some pages are hugely slower than others. And any minor code changes may cause the compiled instructions to be shuffled around, causing page writes to be relatively slower or faster.</p>
<p>For the final experiment, let's control the amount of executed instructions that lie on a page, and see how the write speed is affected. Here's the whole test program:</p>
<div class="fragment"><div class="line">#define change_stk(stk) __asm__ volatile(&quot;mov %0, %%esp&quot; : : &quot;rm&quot;(stk))</div>
<div class="line"> </div>
<div class="line">void do_write(char *addr) {</div>
<div class="line">  constexpr int n = 10000;</div>
<div class="line">  uint64_t start = arch::time::rdtsc();</div>
<div class="line">  for (int i = 0; i &lt; n; ++i) {</div>
<div class="line">    __asm__ volatile(&quot;movb $0, %0&quot; : : &quot;m&quot;(*addr));</div>
<div class="line">  }</div>
<div class="line">  uint64_t end = arch::time::rdtsc();</div>
<div class="line">  nonstd::printf(&quot;cycles/op=%llu\r\n&quot;, (end - start) / n);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__attribute__((section(&quot;.text.entry&quot;))) void _entry() {</div>
<div class="line">  // We&#39;ve established stack is slow, so let&#39;s go somewhere else just</div>
<div class="line">  // to speed things up a bit.</div>
<div class="line">  change_stk(0xDEADBEEF);</div>
<div class="line"> </div>
<div class="line">  constexpr size_t page_sz = 4096;</div>
<div class="line"> </div>
<div class="line">  // Choose a random page that should be empty on startup.</div>
<div class="line">  char *const pg = (char *)0xD0000000;</div>
<div class="line">  nonstd::printf(&quot;Writing to fresh, crunchy ram...\t&quot;);</div>
<div class="line">  do_write(pg);</div>
<div class="line"> </div>
<div class="line">  // Now let&#39;s fill up this page with `ret` (0xC3) instructions.</div>
<div class="line">  // Except for the first byte, which we&#39;ll leave alone since</div>
<div class="line">  // it&#39;ll keep getting overwritten.</div>
<div class="line">  nonstd::printf(&quot;Filling RAM with executable instructions...\t&quot;);</div>
<div class="line">  nonstd::memset(pg + 1, 0xC3, page_sz - 1);</div>
<div class="line">  do_write(pg);</div>
<div class="line"> </div>
<div class="line">  // Now let&#39;s execute some code on this page and see if writing to</div>
<div class="line">  // the page becomes slower.</div>
<div class="line">  for (unsigned i = 1; i &lt; page_sz; ++i) {</div>
<div class="line">    __asm__ volatile(&quot;call *%0&quot; : : &quot;r&quot;(pg + i));</div>
<div class="line">    if ((i + 1) % 128 == 0) {</div>
<div class="line">      nonstd::printf(&quot;Executed %u/%u bytes...\t&quot;, i, page_sz - 1);</div>
<div class="line">      do_write(pg);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // Let&#39;s try slowly overwriting the instructions and see if things</div>
<div class="line">  // are faster again.</div>
<div class="line">  for (unsigned i = 1; i &lt; page_sz; ++i) {</div>
<div class="line">    // Overwrite it with the same bytes as before.</div>
<div class="line">    // It doesn&#39;t really matter what we overwrite it with though.</div>
<div class="line">    *(char *)(pg + i) = 0xC3;</div>
<div class="line">    if ((i + 1) % 128 == 0) {</div>
<div class="line">      nonstd::printf(&quot;Cleared %u/%u bytes...\t&quot;, i, page_sz - 1);</div>
<div class="line">      do_write(pg);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  acpi::shutdown();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The results are exactly as hypothesized:</p>
<div class="fragment"><div class="line">Writing to fresh, crunchy ram...        cycles/op=91</div>
<div class="line">Filling RAM with executable instructions...     cycles/op=12</div>
<div class="line">Executed 127/4095 bytes...      cycles/op=2395</div>
<div class="line">Executed 255/4095 bytes...      cycles/op=4583</div>
<div class="line">Executed 383/4095 bytes...      cycles/op=6735</div>
<div class="line">Executed 511/4095 bytes...      cycles/op=8949</div>
<div class="line">Executed 639/4095 bytes...      cycles/op=11053</div>
<div class="line">...</div>
<div class="line">Executed 3839/4095 bytes...     cycles/op=66152</div>
<div class="line">Executed 3967/4095 bytes...     cycles/op=68458</div>
<div class="line">Executed 4095/4095 bytes...     cycles/op=70473</div>
<div class="line">Cleared 127/4095 bytes...       cycles/op=68180</div>
<div class="line">Cleared 255/4095 bytes...       cycles/op=65913</div>
<div class="line">Cleared 383/4095 bytes...       cycles/op=63619</div>
<div class="line">...</div>
<div class="line">Cleared 3583/4095 bytes...      cycles/op=8908</div>
<div class="line">Cleared 3711/4095 bytes...      cycles/op=6766</div>
<div class="line">Cleared 3839/4095 bytes...      cycles/op=4636</div>
<div class="line">Cleared 3967/4095 bytes...      cycles/op=2427</div>
<div class="line">Cleared 4095/4095 bytes...      cycles/op=12</div>
</div><!-- fragment --><p>So now we've gandered a guess for this slow behavior and it turned out to be right, but ... why? My best guess is that QEMU checks if you've overwritten any instructions so it can clear the icache, allowing for the expected behavior when doing more unconventional things like <a href="https://jpassing.com/2015/01/19/runtime-code-modification-explained-part-2-cache-coherency-issues/">runtime code modification</a>. There's only a cost if we try to write to a page with executable instructions, which shouldn't happen much of the time (text and data/stack/heap regions are typically on separate pages with different memory protections).</p>
<p>After the initial investigation I found that QEMU does not use KVM by default. Turning KVM on (<code>-accel kvm</code>) shows that this behavior is indeed due to QEMU emulation and not the Linux/hardware virtualization. Which makes sense given there's no way the hardware is complicated enough to store which bytes in a page are executable bytes.</p>
<div class="fragment"><div class="line">Writing to fresh, crunchy ram...        cycles/op=63</div>
<div class="line">Filling RAM with executable instructions...     cycles/op=2</div>
<div class="line">Executed 127/4095 bytes...      cycles/op=2</div>
<div class="line">Executed 255/4095 bytes...      cycles/op=2</div>
<div class="line">...</div>
<div class="line">Executed 3967/4095 bytes...     cycles/op=2</div>
<div class="line">Executed 4095/4095 bytes...     cycles/op=2</div>
<div class="line">Cleared 383/4095 bytes...       cycles/op=2</div>
<div class="line">Cleared 511/4095 bytes...       cycles/op=2</div>
<div class="line">...</div>
<div class="line">Cleared 3967/4095 bytes...      cycles/op=2</div>
<div class="line">Cleared 4095/4095 bytes...      cycles/op=2</div>
</div><!-- fragment --><p>I didn't find the exact QEMU code but <a href="https://airbus-seclab.github.io/qemu_blog/tcg_p3.html">this blog post</a> hints at how QEMU converts its load/store IR opcodes into the native x86 opcodes.</p>
<p>The solution to my original problem is to move the stack and (writable) data regions of the kernel onto different pages.</p>
<p>This unexpectedly ended up solving a different but related performance problem. Previously, setting up the page frame array was very slow. Compiling with -O1 helped tremendously (runtime went from ~1min to &lt;1s) and I figured this was due to optimizing the memcpy/memset functions. However, it turns out this operation was simply slow due to the abundance of stack operations &ndash; compiling with -O1 probably avoided writing an intermediate value to the stack in one of these functions. By moving the bootloader stack to a different page, I am able to get similar performance without -O1.</p>
<p>Nice!</p>
<h2><a class="anchor" id="autotoc_md29"></a>
slowness after hlt</h2>
<p>Another issue I noticed when turning on pre-emptive scheduling is that the <code>schedule()</code> call was much slower when pre-emptive scheduling (from the timer interrupt) as opposed to co-operative scheduling (which was essentially being done in a tight loop from the code).</p>
<p>My guess is that the icache gets cold after not accessing it for some time. This is confirmed via a simple experiment:</p>
<div class="fragment"><div class="line">// stolen from wikipedia</div>
<div class="line">unsigned int isqrt(unsigned int y) {</div>
<div class="line">  unsigned int L = 0;</div>
<div class="line">  while ((L + 1) * (L + 1) &lt;= y) {</div>
<div class="line">    L = L + 1;</div>
<div class="line">  }</div>
<div class="line">  return L;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void do_benchmark() {</div>
<div class="line">  uint64_t start = arch::time::rdtsc();</div>
<div class="line">  // Random computation to benchmark.</div>
<div class="line">  isqrt(314159265);</div>
<div class="line">  uint64_t end = arch::time::rdtsc();</div>
<div class="line">  nonstd::printf(&quot;cycles=%llu\r\n&quot;, end - start);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__attribute__((section(&quot;.text.entry&quot;))) void _entry() {</div>
<div class="line">  crt::run_global_ctors();</div>
<div class="line"> </div>
<div class="line">  // Enable interrupts; we need the PIT timer to wake us from hlt.</div>
<div class="line">  arch::idt::init();</div>
<div class="line"> </div>
<div class="line">  for (int i = 0; i &lt; 3; ++i) {</div>
<div class="line">    for (int j = 0; j &lt; 3; ++j) {</div>
<div class="line">      do_benchmark();</div>
<div class="line">    }</div>
<div class="line">    nonstd::printf(&quot;hlt\r\n&quot;);</div>
<div class="line">    __asm__ volatile(&quot;hlt&quot;);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  acpi::shutdown();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output:</p>
<div class="fragment"><div class="line">cycles=258989</div>
<div class="line">cycles=189297</div>
<div class="line">cycles=189221</div>
<div class="line">hlt</div>
<div class="line">cycles=206150</div>
<div class="line">cycles=220419</div>
<div class="line">cycles=190475</div>
<div class="line">hlt</div>
<div class="line">cycles=254999</div>
<div class="line">cycles=230698</div>
<div class="line">cycles=161823</div>
<div class="line">hlt</div>
</div><!-- fragment --><p>The same results with KVM enabled:</p>
<div class="fragment"><div class="line">Enabling interrupts...</div>
<div class="line">cycles=54872</div>
<div class="line">cycles=30286</div>
<div class="line">cycles=42161</div>
<div class="line">hlt</div>
<div class="line">cycles=70262</div>
<div class="line">cycles=30286</div>
<div class="line">cycles=30495</div>
<div class="line">hlt</div>
<div class="line">cycles=70281</div>
<div class="line">cycles=30267</div>
<div class="line">cycles=30476</div>
<div class="line">hlt</div>
</div><!-- fragment --><p>I'm not sure exactly what's going on that causes the icache to get cold &ndash; no other code is running on the OS in the meantime. I imagine QEMU shares the icache with the guest system and it gets cold when the guest system <code>hlt</code>s. With the QEMU (non-KVM) runtime, I imagine there's enough other code running to cause the icache to become even more stale.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
KVM memory invalidation heisenbug</h1>
<p>I thought QEMU used KVM virtualization by default until recently when I learned it has its <a href="https://airbus-seclab.github.io/qemu_blog/tcg_p1.html">own translation layers</a>. When I tried to turn on KVM (<code>-accel kvm</code>), I got some weird issues with the page mapping.</p>
<p>There's a check in the bootloader that the HHDM is set up properly. This checks that the 1MB of memory starting from 0xC0000000 (high-half direct mapping) matches the 1MB starting from 0x0 (direct mapping). We can only check up to 1MB since the lower-half direct mapping is only 1MB for bootstrapping from real mode. We actually do this check twice: once before the page table is set up (check should fail) and once afterwards (check should succeed).</p>
<p>With KVM acceleration turned on, the second check started failing.</p>
<p>I had just set up debugging with symbols at this point, so I tried turning that on. Turns out that breakpoints don't quite work OOTB with KVM so you need <a href="https://forum.osdev.org/viewtopic.php?p=315671&amp;sid=ab78e42403df71a73a191a03d238209a#p315671">a little hack</a>. This hack worked really well.</p>
<p>Now the problem was that the error stopped showing up when running in the debugger, even with no breakpoints installed! Huh. It also only shows up in some build variants when not running in the debugger: clang with default optimization level doesn't cause a failure. Every other build variant causes the failure.</p>
<p>Even weirder, when I put a breakpoint in the comparison failure in the <code>memcmp</code> call, the compared values show as equal. Here's the unadultered <code>memcmp</code> implementation:</p>
<div class="fragment"><div class="line">int memcmp(const void *s1, const void *s2, size_t n) {</div>
<div class="line">  const uint8_t *p1 = (const uint8_t *)s1;</div>
<div class="line">  const uint8_t *p2 = (const uint8_t *)s2;</div>
<div class="line"> </div>
<div class="line">  for (size_t i = 0; i &lt; n; i++) {</div>
<div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If I put a print statement, <code>p1[i]</code> and <code>p2[i]</code> show as equal:</p>
<div class="fragment"><div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      console_printb(p1[i]);</div>
<div class="line">      console_printb(p2[i]);</div>
<div class="line">      console_printl((unsigned)&amp;p1[i]);</div>
<div class="line">      console_printl((unsigned)&amp;p2[i]);</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">// outputs: 0x23 0x23 0x00002008 0xC0002008</div>
</div><!-- fragment --><p>This happens at the same addresses (2008h) for all build variants with failures.</p>
<p>Let's continue this weirdness. If I check for equality again after the print statements, they now compare as equal, causing the check to pass.</p>
<div class="fragment"><div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      console_printb(p1[i]);</div>
<div class="line">      console_printb(p2[i]);</div>
<div class="line">      console_printl((unsigned)&amp;p1[i]);</div>
<div class="line">      console_printl((unsigned)&amp;p2[i]);</div>
<div class="line">      if (p1[i] == p2[i]) {</div>
<div class="line">        continue; // we hit this</div>
<div class="line">      }</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">// outputs same as before but check now passes</div>
</div><!-- fragment --><p>Which means that p1[i] and/or p2[i] changed between the first and second comparison. Now if I take out the print statements, the second comparison still shows these as unequal.</p>
<div class="fragment"><div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      if (p1[i] == p2[i]) {</div>
<div class="line">        continue; // we don&#39;t hit this ... ??? !!!</div>
<div class="line">      }</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">// check fails!</div>
</div><!-- fragment --><p>This feels like a true heisenbug scenario. Oberving the memory (via a print statement, or by running in a debugger) changes the behavior. The only way I was able to show the difference in values was by storing the value to a temporary.</p>
<div class="fragment"><div class="line">    uint8_t c1 = p1[i];</div>
<div class="line">    uint8_t c2 = p2[i];</div>
<div class="line">    if (c1 != c2) {</div>
<div class="line">      console_printb(c1);</div>
<div class="line">      console_printb(c2);</div>
<div class="line">      console_printl((unsigned)&amp;p1[i]);</div>
<div class="line">      console_printl((unsigned)&amp;p2[i]);</div>
<div class="line">      return c1 &lt; c2 ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">/// output: 0x23 0x03 0x00002008 0xC0002008</div>
</div><!-- fragment --><p>So, at the time of the comparison, these values are indeed different. But something changes it soon afterwards. This seems like an issue with caching &ndash; in particular the page mapping cache (the TLB). The TLB cache <em>should</em> be completely flushed when we install the page table by <a href="https://wiki.osdev.org/TLB#Modification_of_paging_structures">setting the <code>cr3</code> register</a>, but let's try flushing it manually.</p>
<div class="fragment"><div class="line">  for (size_t i = 0; i &lt; n; i++) {</div>
<div class="line">    __asm__ volatile(&quot;invlpg %0\n\t&quot;</div>
<div class="line">                     &quot;invlpg %1\n\t&quot;</div>
<div class="line">                     :</div>
<div class="line">                     : &quot;m&quot;(p1[i]), &quot;m&quot;(p2[i]));</div>
<div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">// this works! but...</div>
</div><!-- fragment --><p>This <em>seems</em> to work, but it seems more like a false positive than anything. Really, only flushing the page for <code>p2[i]</code> should make a difference since its value is stale (0x03 should be 0x23), but this <em>also</em> works if we only flush the TLB entry for <code>p1[i]</code>, which doesn't make any sense.</p>
<div class="fragment"><div class="line">  for (size_t i = 0; i &lt; n; i++) {</div>
<div class="line">    __asm__ volatile(&quot;invlpg %0&quot; : : &quot;m&quot;(p1[i]));</div>
<div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">// this works! which doesn&#39;t make any sense</div>
</div><!-- fragment --><p>Furthermore, since we always have this issue for page 0x2008 and 0xC0002008, flushing those TLB entries beforehand should also work, but the check fails if I do the following.</p>
<div class="fragment"><div class="line">  __asm__ volatile(&quot;invlpg 0x00002008\n\t&quot;</div>
<div class="line">                   &quot;invlpg 0xC0002008&quot;);</div>
<div class="line">  for (size_t i = 0; i &lt; n; i++) {</div>
<div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">// check fails</div>
</div><!-- fragment --><p>But the check passes if I do the following, which should be identical in behavior (but inefficient).</p>
<div class="fragment"><div class="line">  for (size_t i = 0; i &lt; n; i++) {</div>
<div class="line">    __asm__ volatile(&quot;invlpg 0x00002008\n\t&quot;</div>
<div class="line">                     &quot;invlpg 0xC0002008&quot;);</div>
<div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">// check passes ... why???</div>
</div><!-- fragment --><p>Actually, putting <em>any</em> address as argument to <code>invlpg</code> works when it's in the loop. It turns out that there's a temporal aspect to this &ndash; if we call <code>invlpg</code> on <em>any address</em> shortly before we reach the 0x2008 address, that's good enough to make the check pass.</p>
<div class="fragment"><div class="line">  for (size_t i = 0; i &lt; n; i++) {</div>
<div class="line">    // Check fails with 0x1FF0 but passes with 0x1FF8-0x2008.</div>
<div class="line">    if ((unsigned)&amp;p1[i] == 0x1FF0) {</div>
<div class="line">      __asm__ volatile(&quot;invlpg 0&quot;);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if (p1[i] != p2[i]) {</div>
<div class="line">      return p1[i] &lt; p2[i] ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">// check may pass or fail based on when we call `invlpg`</div>
</div><!-- fragment --><p>The behavior seems a bit probabilistic as if there's a race condition. For example, if we set the check to 0x1FF8, the check passes roughly half of the time on my machine.</p>
<p>You may notice that I haven't posted any assembly here yet, and the reason is I haven't found anything conclusive there. I also have no idea where this magic address 0x2008 comes from. This is lower in memory than anything installed by the bootloader (lowest memory is the stack which is just under 0x7000) or in the <a href="https://wiki.osdev.org/Memory_Map_(x86)">standard low memory map</a>.</p>
<p>I give up at this point. I notice that the check works if I explicitly read from the 0x2000 memory page beforehand. Hence the following kludge just after setting up the page table:</p>
<div class="fragment"><div class="line">// Without this running with `-accel kvm` bugs out. I have no idea</div>
<div class="line">// why. Without this we get some _really_ weird behavior later on</div>
<div class="line">// when trying to access address 0x2008/0xC0002008 as if the TLB is</div>
<div class="line">// out of date. It&#39;s a flakey behavior and really annoying to debug</div>
<div class="line">// (doesn&#39;t show up when running in the debugger). Invalidating the</div>
<div class="line">// mapping from the TLB (via invlpg) doesn&#39;t seem to help; the only</div>
<div class="line">// thing that helps is accessing the memory address before the first</div>
<div class="line">// time it&#39;s accessed. This will probably surface as other bugs in</div>
<div class="line">// the future, IDK.</div>
<div class="line">volatile int _ = *(int *)0x2000;</div>
</div><!-- fragment --><p>This works if I dereference any address in the range <code>0x1FFD</code> through <code>0x2FFF</code>, which is an almost-page-oriented behavior. I have no idea why the last 12 bytes of the 0x1000 page works here, but it seems to be consistent behavior.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
A fun memset</h1>
<p>Overwriting stack memory or the GDT can lead to fun errors! Both of the following happened on the same <code>memset()</code> call, leading to double the f(r)u(stratio)n!</p>
<p>Clobbering the stack: I'd misplaced it via a bad asm instruction :/ Memory corruption is a fun thing. Led to a page fault within <code>memset()</code> (not the source/destination memory regions, but the text region :/).</p>
<p>Obliterating the GDT: I marked the bootloader text region reclaimable by the kernel and forgot the GDT was in there. The GP faults with error 0x8 (segment-related error) should've been a clue. This only popped up after the next <code>iret</code> since that's the next time a segment register is loaded from the GDT. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
